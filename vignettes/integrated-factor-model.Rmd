---
title: "R Notebook"
output: html_notebook
---

- can't run this in bombas or any recast b/c recast project is pinned to rstan 2.18
- this model requires stanheaders 2.19.2
- stanheaders can't be above rstan

```{r}
library(tidyverse)
library(rstan)
library(bayesplot)
library(recast)
weekly_clean_data = read_csv("../../weekly_clean_data.csv")
dfa_pred = stan_model("../src/stan_files/dfa-pred.stan")
stanmodels <- list()
stanmodels$dfa_pred = dfa_pred
```


The first thing I need to do is to generate all the parameters for the factor part of the model:


```{r}
.generate_factor_stan_data <- function(
                    y,
                    depvar,
                    num_trends = 1,
                    varIndx = NULL,
                    zscore = T,
                    nu_fixed = 101,
                    est_correlation = FALSE,
                    estimate_nu = FALSE,
                    estimate_trend_ar = FALSE,
                    estimate_trend_ma = FALSE,
                    sample = TRUE,
                    data_shape = "long",
                    obs_covar = NULL,
                    pro_covar = NULL) {
  predictors <- y
  
  data_shape <- match.arg(data_shape)
  if (ncol(y) > nrow(y) && data_shape == "long") {
    warning(
      "ncol(y) > nrow(y) and data_shape == 'long'; are you sure your",
      "input data is in long format?"
    )
  }
  if (ncol(y) < nrow(y) && data_shape == "wide") {
    warning(
      "ncol(y) < nrow(y) and data_shape == 'wide'; are you sure your",
      "input data is in wide format?"
    )
  }
  if (data_shape == "long") {
    y <- t(y)
  }

  if (nrow(y) < 3) {
    stop("fit_dfa() only works with 3 or more time series. We detected ",
      nrow(y), " time series.")
  }

  if(!is.null(obs_covar)) {
    if(ncol(obs_covar) != 4) {
      stop("observation covariates must be in a data frame with 4 columns")
    }
  }
  if(!is.null(pro_covar)) {
    if(ncol(pro_covar) != 4) {
      stop("process covariates must be in a data frame with 4 columns")
    }
  }

  # parameters for DFA
  N <- ncol(y) # number of time steps
  P <- nrow(y) # number of time series
  K <- num_trends # number of dfa trends
  nZ <- P * K - sum(seq_len(K)) # number of non-zero parameters that are unconstrained

  for (i in seq_len(P)) {
    if (zscore) {
      if (length(unique(na.omit(c(y[i, ])))) == 1L) {
        stop("Can't scale one or more of the time series because all values ",
          "are the same. Remove this/these time series or set `zscore = FALSE`.",
          call. = FALSE
        )
      }
      y[i, ] <- scale(y[i, ], center = TRUE, scale = TRUE)
    } else {
      y[i, ] <- scale(y[i, ], center = TRUE, scale = FALSE)
    }
  }
  Y <- y # included in returned object at end

  # mat_indx now references the unconstrained values of the Z matrix.
  mat_indx <- matrix(0, P, K)
  start <- 1
  for (k in seq_len(K)) {
    for (p in seq(k + 1, P)) {
      mat_indx[p, k] <- start
      start <- start + 1
    }
  }
  # row_indx and col_indx now references the unconstrained values of the Z matrix.
  row_indx <- matrix((rep(seq_len(P), K)), P, K)[mat_indx > 0]
  col_indx <- matrix(sort(rep(seq_len(K), P)), P, K)[mat_indx > 0]

  diag(mat_indx) <- 1
  row_indx_z <- matrix((rep(seq_len(P), K)), P, K)[mat_indx == 0]
  col_indx_z <- matrix(sort(rep(seq_len(K), P)), P, K)[mat_indx == 0]
  row_indx_z <- c(row_indx_z, 0, 0) # +2 zeros for making stan ok with data types
  col_indx_z <- c(col_indx_z, 0, 0) # +2 zeros for making stan ok with data types
  nZero <- length(row_indx_z)

  # set the model up to have shared variances
  if (is.null(varIndx)) {
    varIndx <- rep(1, P)
  }
  nVariances <- length(unique(varIndx))

  # indices of positive values - Stan can't handle NAs
  row_indx_pos <- matrix(rep(seq_len(P), N), P, N)[!is.na(y)]
  col_indx_pos <- matrix(sort(rep(seq_len(N), P)), P, N)[!is.na(y)]
  n_pos <- length(row_indx_pos)

  row_indx_na <- matrix(rep(seq_len(P), N), P, N)[is.na(y)]
  col_indx_na <- matrix(sort(rep(seq_len(N), P)), P, N)[is.na(y)]
  n_na <- length(row_indx_na)

  y <- y[!is.na(y)]

  # flag for whether to use a normal dist
  use_normal <- if (nu_fixed > 100) 1 else 0
  if (estimate_nu) use_normal <- 0 # competing flags

  # covariates
  if(!is.null(obs_covar)) {
    obs_covar_index = as.matrix(obs_covar[,c("time","timeseries","covariate")])
    num_obs_covar = nrow(obs_covar_index)
    n_obs_covar = length(unique(obs_covar_index[,"covariate"]))
    obs_covar_value = obs_covar[,"value"]
  } else {
    num_obs_covar = 0
    n_obs_covar = 0
    obs_covar_value = c(0)[0]
    obs_covar_index = matrix(0,1,3)[c(0)[0],]
  }
  if(!is.null(pro_covar)) {
    pro_covar_index = as.matrix(pro_covar[,c("time","trend","covariate")])
    num_pro_covar = nrow(pro_covar_index)
    n_pro_covar = length(unique(pro_covar_index[,"covariate"]))
    pro_covar_value = pro_covar[,"value"]
  } else {
    num_pro_covar = 0
    n_pro_covar = 0
    pro_covar_value = c(0)[0]
    pro_covar_index = matrix(0,1,3)[c(0)[0],]
  }

  data_list <- list(
    N = N,
    P = P,
    K = K,
    nZ = nZ,
    y = y,
    row_indx = row_indx,
    col_indx = col_indx,
    nZero = nZero,
    varIndx = varIndx,
    nVariances = nVariances,
    row_indx_z = row_indx_z,
    col_indx_z = col_indx_z,
    nZero = nZero,
    row_indx_z = row_indx_z,
    col_indx_z = col_indx_z,
    row_indx_pos = row_indx_pos,
    col_indx_pos = col_indx_pos,
    n_pos = n_pos,
    row_indx_na = row_indx_na,
    col_indx_na = col_indx_na,
    n_na = n_na,
    nu_fixed = nu_fixed,
    estimate_nu = as.integer(estimate_nu),
    use_normal = use_normal,
    est_cor = as.numeric(est_correlation),
    est_phi = as.numeric(estimate_trend_ar),
    est_theta = as.numeric(estimate_trend_ma),
    num_obs_covar = num_obs_covar,
    n_obs_covar = n_obs_covar,
    obs_covar_value = obs_covar_value,
    obs_covar_index = obs_covar_index,
    num_pro_covar = num_pro_covar,
    n_pro_covar = n_pro_covar,
    pro_covar_value = pro_covar_value,
    pro_covar_index = pro_covar_index,
    depvar = depvar,
    predictors = predictors
  )

  return(data_list)
}

generate_factor_stan_data <- function(depvar_name, chan_names, ...) {
  
  depvar = select(weekly_clean_data, !!depvar_name)
  y      = as.data.frame(weekly_clean_data[, chan_names])
  
  
  .generate_factor_stan_data(y, depvar, ...)
}

```

The second thing I need to do is to generate all the parameters for the custom filter part of the model: 

```{r}

generate_obs_stan_data <- function(depvar_name, chan_names, num_trends, config_dir) {

  y_actual = weekly_clean_data[, depvar_name][[1]]
  
  if(file.exists(file.path(tempdir(), "test_sim.yaml"))) {
    file.remove(file.path(tempdir(), "test_sim.yaml"))
  }
  
  recast::create_default_chan_config(
    subset_name = "test",
    depvar_name = "sim",
    chan_names = chan_names, 
    config_dir = config_dir
  )

  orig_config = yaml::read_yaml(file.path(config_dir, "test_sim.yaml"))

  trend_template = orig_config[1]

  trend_template[[1]]$ub = Inf
  trend_template[[1]]$lb = -Inf
  trend_template[[1]]$q80 = sd(y_actual)/10
  trend_template[[1]]$q20 = -sd(y_actual)/10
  trend_template[[1]]$mu = 0.0001
  trend_template[[1]]$adstock = 0

  new_config = orig_config
  for(i in num_trends:1) {
    trend_component = trend_template
    names(trend_component)[1] = str_c("t", i)
    new_config = c(trend_component, new_config)
  }

  chan_params_factor = recast::longify_chan_config(new_config)
  return(chan_params_factor)
}

```

Now I need to put it all together:

```{r}

chan_names = colnames(weekly_clean_data)[7:16]
depvar_name = "total_sales"
config_dir = tempdir()

factor_data = generate_factor_stan_data(depvar_name, chan_names, num_trends = 3, estimate_nu = T, 
                                        zscore = T)

channel_data = generate_obs_stan_data(depvar_name, chan_names, num_trends = 3, config_dir)

stan_data = c(factor_data, channel_data, n_holdout = 0)

```

And finally, to start sampling:

```{r}

fuck = sampling(
  stanmodels$dfa_pred,
  stan_data,
  iter = 1,
  chains = 1
)

```

